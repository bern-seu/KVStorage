syntax = "proto3";
package raftRpcProctoc;
option cc_generic_services = true;//开启stub服务
//raft节点提供的rpc服务与方法描述,通信协议

//日志实体,Raft 日志中存储的最小单位。
message LogEntry{
    bytes Command  =1;// 具体的命令（比如 "set x=10"）
	int32 LogTerm   =2;// 这条日志是在哪个任期产生的
	int32 LogIndex  = 3;// 这条日志在数组中的索引
}
// Leader 发给 Follower 的包。只有Leader会发送，Followe是接收
message AppendEntriesArgs  {
	int32 Term        =1;// Leader 当前的任期（我是第几届总统）
	int32 LeaderId       =2;// Leader 的 ID（比如 IP:Port）
    // --- 核心一致性检查字段 ---
	int32 PrevLogIndex =3;// 我发的新日志之前，前一条日志的索引是多少？
	int32 PrevLogTerm  =4;// 那前一条日志的任期是多少？
    // 作用：Follower 收到后会检查自己相同位置是否有这条日志。
    // 如果没有或 Term 不对，说明 Follower 也就是“跟丢了”，拒绝接收新日志。
    // -------------------------
	repeated LogEntry Entries  = 5;// 真正要同步的日志条目（心跳时为空）
	int32 LeaderCommit  = 6;// Leader 已经提交到哪了？Follower 看到这个数，就知道自己也可以把这些日志应用到状态机了
}

message AppendEntriesReply {
	int32 Term =1;             // 回复给leader的自身的term，如果 Leader 发现 Follower 的 Term 比自己大，会变为Follower。
	bool Success      =2;      // true: 同步成功；false: 一致性检查失败（PrevLogIndex 不匹配）。
    // --- 优化字段 ---
	int32 UpdateNextIndex = 3;               // 快速回退优化。
    // 如果 Success = false，Follower 可以告诉 Leader：“在这个位置之前我都没冲突”，
    // 这样 Leader 不用一次次减 1 去试，可以直接跳跃式回退索引，加快恢复速度。
	int32 AppState        =4; // 用来标识节点（网络）状态（如网络是否繁忙等）
}

//当 Leader 心跳超时，Follower 变成 Candidate 发起投票
message RequestVoteArgs  {
	int32 Term         =1;  // 我竞选的是第几届？
	int32 CandidateId  =2;  // 我是谁？
    // --- 选举限制（安全性）字段 ---
	int32 LastLogIndex =3;  // 我这里最后一条日志索引是多少
	int32 LastLogTerm  =4;  // 我这里最后一条日志的任期是多少
    // 作用：Raft 规定，只有日志“最新、最全”的人才有资格当 Leader。
    // 如果 Voter 发现 Candidate 的日志比自己的旧，就会拒绝投票。
}

// RequestVoteReply
// example RequestVote RPC reply structure.
// field names must start with capital letters!
message RequestVoteReply  {
	int32 Term        =1;   // 如果 Candidate 发现 Voter 的 Term 比自己大，说明自己落伍了，退选。
	bool VoteGranted  =2;   // true: 投给你；false: 不投。
	int32 VoteState   =3;   //  投票状态。
}

//当日志太长占满内存时，节点会生成快照（Snapshot），把之前的日志删掉。如果一个 Follower 落后太多，Leader 发送日志已经接不上了（因为 Leader 已经把旧日志删了），Leader 就会直接把快照发给它。
message InstallSnapshotRequest  {
	int32 LeaderId                 =1;
	int32 Term                     =2;
	int32 LastSnapShotIncludeIndex =3;  // 快照里包含的最后一条日志是第几条？
	int32 LastSnapShotIncludeTerm  =4;  // 那条日志的任期是多少？
	bytes Data                     =5;  // 快照的具体二进制数据
}

//只用返回Term，因为对于快照只要Term是符合的就是无条件接受的
message InstallSnapshotResponse  {
	int32 Term  = 1;    // 只需要回 Term。通常快照是无条件接受的，除非 Term 过期。
}

service raftRpc {
    rpc AppendEntries(AppendEntriesArgs) returns(AppendEntriesReply);
    rpc InstallSnapshot (InstallSnapshotRequest) returns (InstallSnapshotResponse);
    rpc RequestVote (RequestVoteArgs) returns (RequestVoteReply);
}